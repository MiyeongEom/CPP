#include <iostream>
using namespace std;
// 동적할당

// 메모리 구조 복습
// 실행할 코드가 저장 -> 코드 영역
// 전역/정적 변수 -> 데이터 영역
// 지역변수/매개변수 -> 스택 영역
// 동적할당 -> 힙 영역

// 실제 상황 )
// - MMORPG 동접 1명~5만명, 몬스터 1마리~500만마리
// - 몬스터 생성 이벤트 -> 5분 동안 몬스터가 10배 많이 나옴

// 스택 영역
// - 함수가 끝나면 정리되는 메모리
// - 잠시 함수에 매개변수 넘기거나 하는 용도 ok

// 메모리 영역
// - 프로그램이 실행되는 도중에 무조건 사용되는 메모리

// 이야, 우리 몬스터 어디에 생성해야 되냐..?
// 희망 사항 ) 필요할 때 사용하고 필요 없으면 반납할 수 있어야 함
// 그러면서 스택과 다르게 우리가 생성, 소명 시점을 관리할 수 있는
// -> HEAP

// 동적할당과 연관된 함수/연산자
// : malloc, free, new, delete, new[], delete[]

// malloc 
// - 할당할 메모리 크기 건내줌
// - 메모리 할당 후 시작 주소를 가리키는 포인터 반환 ( 메모리 부족하면 NULL )

// free
// - malloc (혹은 기타 calloc, realloc .. ) 을 통해 할당된 영역 해제
// - 힙 관리자가 할당/미할당 여부를 구분해서 관리

// new / delete
// - C++에 추가됨
// - malloc/free는 함수 !
// - new/delete는 연산자 (operator)

// new[] / delete[]
// - 배열과 같이 n개 데이터를 같이 할당하려면

// malloc/free vs now/delete
// - 사용 편의성 -> new/delete
// - 타입에 상관없이 특정크기의 메모리 영역을 할당받으려면? -> malloc/free

// 가장 중요한 차이
// new/delete는 생성타입이 클래스일 경우 생성자와 소멸자를 호출해준다!!

class Monster
{
public:
	int hp;
	int x;
	int y;
};

int main()
{
	// 유저 영역 [메모장] [LOL] [동영상 플레이어] ...  -> 독립적 실행됨
	// ----------------------------------------------
	// 커널 영역(window 등의 핵심 코드)

	// 메모리란건 유저 영역이 필요하면 커널 영역에 요청해 사용됨
	// 유저 영역 ) 운영체제에서 제공되는 API 호출
	// 커널 영역 ) 메모리 할당해 건네줌
	// 유저 영역 ) ㄳ 잘쓸게

	// C++에선 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
	// 단, 정말 원한다면 우리가 직접 API를 이용해 생성하고 관리 가능 (MMORPG 서버 메모리 폴링)

	// void * ?
	// *가 있으니 포인터는 포인터 (주소를 담는 바구니)
	// 타고가면 void 아무 것도 없는게 아님.
	// 타고가면 void 뭐가 있는지 모르겠으니 너가 적당히 변환해서 사용해라라는 의미

	void* pointer = malloc(12);  // 12바이트

	Monster* m1 = (Monster*)pointer;
	m1->hp = 100;
	m1->x = 1;
	m1->y = 2;

	// heap overflow
	// - 유효한 힙 범위를 초과해서 사용하는 문제

	// 만약 free하지 않으면 메모리 누수
	free(pointer); //반환

	// free를 여러번 하면 ?? -> Double Free
	// 이건 대부분 그냥 크래시만 나고 끝남.

	// User-After-Free
	// - 프로그래머 입장 : 조졌다!
	// - 해커 입장 : 심봤다! (그러니 조심!)
	// m1->hp = 100;
	// m1->x = 1;
	// m1->y = 2;

	// 여기까지 C언어에서 다루었던 내용
	// 객체 하나 -> new/delete
	Monster* m2 = new Monster;  // type을 넣어주면 그 크기만큼 생성해줌
	m2->hp = 100;
	m2->x = 1;
	m2->y = 2;
	delete m2;

	// 위에서 다룬 버그는 공통적으로 존재

	Monster* m3 = new Monster[5];  // 5마리 몬스터
	m3->hp = 100;
	m3->x = 1;
	m3->y = 2;
	delete[] m3;

}
